# A0147944U
###### \java\seedu\task\commons\core\Config.java
``` java
/**
 * Config values used by the app
 */
public class Config {

    public static final String DEFAULT_CONFIG_FILE = "config.json";

    // Config values customizable through config file
    private String appTitle = "Task App";
    private Level logLevel = Level.INFO;
    private String userPrefsFilePath = "preferences.json";
    private String taskManagerFilePath = "data/taskmanager.xml";
    private String taskManagerName = "MyTaskManager";
    private String sortPreference = "Default";


    public Config() {
    }

    public String getAppTitle() {
        return appTitle;
    }

    public void setAppTitle(String appTitle) {
        this.appTitle = appTitle;
    }

    public Level getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(Level logLevel) {
        this.logLevel = logLevel;
    }

    public String getUserPrefsFilePath() {
        return userPrefsFilePath;
    }

    public void setUserPrefsFilePath(String userPrefsFilePath) {
        this.userPrefsFilePath = userPrefsFilePath;
    }

    public String getTaskManagerFilePath() {
        return taskManagerFilePath;
    }

    public void setTaskManagerFilePath(String taskManagerFilePath) {
        this.taskManagerFilePath = taskManagerFilePath;
    }

    public String getTaskManagerName() {
        return taskManagerName;
    }

    public void setTaskManagerName(String taskManagerName) {
        this.taskManagerName = taskManagerName;
    }
    
    public String getsortPreference() {
        return sortPreference;
    }

    public void setsortPreference(String sortPreference) {
        this.sortPreference = sortPreference;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this){
            return true;
        }
        if (!(other instanceof Config)){ //this handles null as well.
            return false;
        }

        Config o = (Config)other;

        return Objects.equals(appTitle, o.appTitle)
                && Objects.equals(logLevel, o.logLevel)
                && Objects.equals(userPrefsFilePath, o.userPrefsFilePath)
                && Objects.equals(taskManagerFilePath, o.taskManagerFilePath)
                && Objects.equals(taskManagerName, o.taskManagerName)
                && Objects.equals(sortPreference, o.sortPreference);
    }

    @Override
    public int hashCode() {
        return Objects.hash(appTitle, logLevel, userPrefsFilePath, taskManagerFilePath, taskManagerName, sortPreference);
    }

    @Override
    public String toString(){
        StringBuilder sb = new StringBuilder();
        sb.append("App title : " + appTitle);
        sb.append("\nCurrent log level : " + logLevel);
        sb.append("\nPreference file Location : " + userPrefsFilePath);
        sb.append("\nLocal data file location : " + taskManagerFilePath);
        sb.append("\nTaskManager name : " + taskManagerName);
        sb.append("\nCurrent Sorting Preference : " + sortPreference);
        return sb.toString();
    }

}
```
###### \java\seedu\task\commons\util\FilePickerUtil.java
``` java
/**
 * A class for JFileChooser, a GUI to select a file.
 */
public class FilePickerUtil {

    /**
     * Retrieves filepath of the selected XML file via a Open GUI
     * 
     * @return FilePath as a String without its extension
     * @throws IOException
     *             if there was an error during reading the file
     */
    public static String openXMLFile() {
        try {
            UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
                | UnsupportedLookAndFeelException e1) {
            e1.printStackTrace();
        }
        JFileChooser chooser = new JFileChooser(".");
        chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter filter = new FileNameExtensionFilter("XML files", "xml");
        chooser.setFileFilter(filter);
        int returnVal = chooser.showOpenDialog(null);
        String FilePath = "";
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            try {
                FilePath = chooser.getSelectedFile().getCanonicalPath().toString();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return FilenameUtils.removeExtension(FilePath);
    }

    /**
     * Retrieves filepath of the selected XML file via a Save GUI
     * 
     * @return FilePath as a String without its extension
     * @throws IOException
     *             if there was an error during reading the file
     */
    public static String saveXMLFile() {
        try {
            UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException
                | UnsupportedLookAndFeelException e1) {
            e1.printStackTrace();
        }
        JFileChooser chooser = new JFileChooser(".");
        chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        FileNameExtensionFilter filter = new FileNameExtensionFilter("XML files", "xml");
        chooser.setFileFilter(filter);
        int returnVal = chooser.showSaveDialog(null);
        String FilePath = "";
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            try {
                FilePath = chooser.getSelectedFile().getCanonicalPath().toString();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return FilenameUtils.removeExtension(FilePath);
    }

}
```
###### \java\seedu\task\logic\commands\BackupCommand.java
``` java
/**
 * Saves task manager data at specified directory.
 */
public class BackupCommand extends Command {

    private static final Logger logger = LogsCenter.getLogger(ConfigUtil.class);

    public static final String COMMAND_WORD = "backup";

    public static final String COMMAND_WORD_ALT = "b";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves TaskManager in given directory. \n"
            + "If only filename is given, file is saved in root directory of TaskManager. \n"
            + "Parameters: directory/filename OR filename\n"
            + "Example: " + COMMAND_WORD + " c:/Users/user/Desktop/TaskManagerBackup1 OR TaskManagerBackup2";

    public static final String MESSAGE_BACKUP_SUCCESS = "Backup successful: %1$s %2$s";

    public static final String MESSAGE_BACKUP_FAILURE = "Backup unsuccessful: %1$s , invalid location";

    public static final String MESSAGE_BACKUP_ERROR = "Backup unsuccessful: %1$s , data mismatch";

    /* This constant string variable is file extension of the storage file */
    private final String FILE_EXTENSION = ".xml";

    /* This is the path of the current data file */
    private String _source;

    /* This is the path of the backup data file */
    private String _destination;

    /**
     * This is information if the command had overwritten an existing data file
     * or created a new data file
     */
    private String _overwrite;

    public BackupCommand(String destination) {
        // Prepare files
        appendExtension(destination);
        getCurrentData();
        File newFile = new File(this._destination);
        File source = new File(this._source);

        // Cancel attempt if unable to retrieve source
        if (!source.exists()) {
            return;
        }
        createFileIfNotExisting(newFile);
        copyData(newFile, source);
    }

    /**
     * Replaces data in Config file with the updated data
     * 
     * @param newFile config file to update
     * @param source config file to get data from
     */
    private void copyData(File newFile, File source) {
        // Copy current data to
        try {
            FileUtils.copyFile(source, newFile);
        } catch (IOException e) {
            logger.warning("Error copying current data to defined backup file.");
            e.printStackTrace();
        }
    }

    /**
     * Creates file on drive if it does not exist
     * 
     * @param newFile data file to create
     */
    private void createFileIfNotExisting(File newFile) {
        if (!FileUtil.isFileExists(newFile)) {
            // Update string on creation of file
            _overwrite = "created";
            try {
                FileUtil.createFile(newFile);
            } catch (IOException e) {
                logger.warning("Error creating defined backup file.");
                e.printStackTrace();
            }
        } else {
            // Update string on overwriting a file
            _overwrite = "overwritten";
        }
    }

    /**
     * Appends FILE_EXTENSION to given destination.
     * This ensures user will not accidentally override non-xml files.
     * 
     * @param destination path of backup data file provided by user
     */
    private void appendExtension(String destination) {
        if (destination != null) {
            _destination = destination + FILE_EXTENSION;
        }
    }

    /**
     * Read config file to determine location of current data accessed in TaskManager.
     */
    private void getCurrentData() {
        Config config = new Config();
        File configFile = new File("config.json");
        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file " + "config.json" + ": " + e);
            try {
                throw new DataConversionException(e);
            } catch (DataConversionException e1) {
                e1.printStackTrace();
            }
        }
        _source = config.getTaskManagerFilePath();
    }

    @Override
    public CommandResult execute(boolean isUndo) {

        /**
         * Check if new backup file was not created
         * Possible scenario where file was not created:
         * Given path is protected and thus inaccessible by TaskManager or Given path can not exist
         * i.e. invalid drive letter, invalid characters
         */
        assert _destination != null;
        if (!FileUtil.isFileExists(new File(_destination))) {
            return new CommandResult(String.format(MESSAGE_BACKUP_FAILURE, _destination));
        }

        /**
         * Check if new backup file data matches the current data.
         * Possible scenario where it doesn't match:
         * If a file of same path as given already exists and is write-protected
         */
        try {
            String destinationFileData = FileUtil.readFromFile(new File(_destination));
            String sourceFileData = FileUtil.readFromFile(new File(_source));
            if (!destinationFileData.equals(sourceFileData)) {
                return new CommandResult(String.format(MESSAGE_BACKUP_ERROR, _destination));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        /**
         * Considered successful if it passes the two tests above
         */
        return new CommandResult(String.format(MESSAGE_BACKUP_SUCCESS, _destination, _overwrite));
    }

    @Override
    public CommandResult execute(int index) {
        return null;
    }

}
```
###### \java\seedu\task\logic\commands\DirectoryCommand.java
``` java
/**
 * Changes working task manager data to data at specified directory.
 */
public class DirectoryCommand extends Command {

    private static final Logger logger = LogsCenter.getLogger(ConfigUtil.class);

    public static final String COMMAND_WORD = "directory";

    public static final String COMMAND_WORD_ALT = "dir";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Load TaskManager with data in given directory. \n"
            + "Parameters: directory/filename OR filename\n"
            + "Example: " + COMMAND_WORD + " c:/Users/user/Desktop/TaskManagerBackup1 OR TaskManagerBackup2";

    public static final String MESSAGE_NEW_DIRECTORY_SUCCESS = "New data: %1$s";
    
    public static final String MESSAGE_UNSUPPORTED_OPERATING_SYSTEM = "Unsupported operating system, please manually close application and start it again.";

    public static final String MESSAGE_FILE_NOT_FOUND_ERROR = "File does not exist: %1$s";

    /* This constant string variable is file extension of the storage file. */
    private final String FILE_EXTENSION = ".xml";

    /* This is the path of the selected storage file. */
    private String _destination;

    public DirectoryCommand(String newFilePath) {
        appendExtension(newFilePath);
        // Check if file supplied by user actually exists
        if (new File(_destination).exists()) {
            Config config = getConfig();
            updateConfigWithNewFilePath(config);
            saveConfig(config);
            /*
             * try { ReadOnlyTaskManager newData =
             * XmlFileStorage.loadDataFromSaveFile(new File(_destination));
             * model.resetData(newData); } catch (DataConversionException e) {
             * // TODO Auto-generated catch block e.printStackTrace(); } catch
             * (FileNotFoundException e) { // TODO Auto-generated catch block
             * e.printStackTrace(); }
             */
        }
    }

    /**
     * Change TaskManager file path in Config
     * 
     * @param config Config to update
     */
    private void updateConfigWithNewFilePath(Config config) {
        config.setTaskManagerFilePath(_destination);
    }

    /**
     * Saves changes made to Config
     * 
     * @param config Config file with updated data
     */
    private void saveConfig(Config config) {
        try {
            ConfigUtil.saveConfig(config, "config.json");
        } catch (IOException e) {
            logger.warning("Error saving to config file : " + e);
            e.printStackTrace();
        }
    }

    /**
     * Retrieves Config file
     * 
     * @return the deserialized config
     */
    private Config getConfig() {
        Config config = new Config();
        File configFile = new File("config.json");
        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file " + "config.json" + ": " + e);
            try {
                throw new DataConversionException(e);
            } catch (DataConversionException e1) {
                e1.printStackTrace();
            }
        }
        return config;
    }

    /**
     * Appends FILE_EXTENSION to given destination.
     * This ensures user will not accidentally override non.xml files.
     * 
     * @param destination path of new data file provided by user
     */
    private void appendExtension(String destination) {
        if (destination != null) {
            _destination = destination + FILE_EXTENSION;
        }
    }

    @Override
    public CommandResult execute(boolean isUndo) {
        // Check if file supplied by user exists
        if (!new File(_destination).exists()) {
            return new CommandResult(String.format(MESSAGE_FILE_NOT_FOUND_ERROR, _destination));
        }

        assert model != null;
        if (!isOperatingSystemSupported()) {
            return new CommandResult(String.format(MESSAGE_UNSUPPORTED_OPERATING_SYSTEM));
        }
        restartTaskManager();
        // Shut down current TaskManager
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
        return new CommandResult(String.format(MESSAGE_NEW_DIRECTORY_SUCCESS, _destination));
    }

    private Boolean isOperatingSystemSupported() {
        //first check if Desktop is supported by Platform or not
        if(Desktop.isDesktopSupported()){
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Run TaskManager.jar
     */
    private void restartTaskManager() {
        logger.info("============================ [ Restarting Task Manager ] =============================");
        File Taskmanager = new File("TaskManager.jar");
        Desktop desktop = Desktop.getDesktop();
        if (Taskmanager.exists()) {
            try {
                desktop.open(Taskmanager);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    
    /* Older method to restart TaskManger, keeping for knowledge
    /**
     * Locates TaskManager.jar file and silently run it via Windows Command Line
     *
    private void restartTaskManagerOnWindows() {
        logger.info("============================ [ Restarting Task Manager ] =============================");
        String command = "";
        String filePath = Paths.get(".").toAbsolutePath().normalize().toString() + "\\";
        command = "/c cd /d \"" + filePath + "\" & TaskManager.jar & exit";
        logger.info("DOS command generated:" + command);
        try {
            new ProcessBuilder("cmd", command).start();
        } catch (IOException e) {
            logger.warning("Error starting process. " + e);
        }
    }
    */

    @Override
    public CommandResult execute(int index) {
        return null;
    }

}
```
###### \java\seedu\task\logic\commands\RepeatCommand.java
``` java
/**
 * Favorite a task from the task manager.
 */
public class RepeatCommand extends Command {

    public static final String COMMAND_WORD = "repeat";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Repeat the task identified by the index number used in the last task listing with given interval.\n"
            + "Parameters: INDEX TASKNAME, INTERVAL\n"
            + "Example: " + COMMAND_WORD
            + " 4 weekly";

    public static final String MESSAGE_REPEAT_TASK_SUCCESS = "Task %1$s repeating: %2$s";
    
    public static final String MESSAGE_INVALID_INTERVAL = "Invalid interval provided: %1$s\n"
            + "Allowed intervals: daily, weekly, fortnightly, monthly, yearly\n"
            + "or d, w, f, m, y respectively.";

    public final int targetIndex;

    protected String interval;

    public RepeatCommand(int targetIndex, String interval) {
        this.targetIndex = targetIndex;
        this.interval = interval;
    }

    @Override
    public CommandResult execute(boolean isUndo) {
        assert model != null;
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask selectedTask = lastShownList.get(targetIndex - 1);
        if (this.interval.equals("daily") || this.interval.equals("d")) {
            this.interval = "daily";
        } else if (this.interval.equals("weekly") || this.interval.equals("w")) {
            this.interval = "weekly";
        } else if (this.interval.equals("fortnightly") || this.interval.equals("f")) {
            this.interval = "fortnightly";
        } else if (this.interval.equals("monthly") || this.interval.equals("m")) {
            this.interval = "monthly";
        } else if (this.interval.equals("yearly") || this.interval.equals("y")) {
            this.interval = "yearly";
        } else if (this.interval.equals("stop") || this.interval.equals("end")) {
            this.interval = "false";
        } else {
            return new CommandResult(String.format(MESSAGE_INVALID_INTERVAL, interval));
        }
        selectedTask.getRecurring().setRecurring(interval);
        return new CommandResult(String.format(MESSAGE_REPEAT_TASK_SUCCESS, selectedTask.getName(), interval));
    }

    @Override
    public CommandResult execute(int index) {
        return null;
    }
}
```
###### \java\seedu\task\logic\commands\SortCommand.java
``` java
/**
 * Lists all tasks in the task manager to the user.
 */
public class SortCommand extends Command {

    public static final String COMMAND_WORD = "sort";
    
    public static final String COMMAND_WORD_ALT = "s";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Sorts tasks according to specified parameters.\n"
            + "If parameter is not given, tasks will be sorted by a default preset.\n"
            + "Parameters: PARAMETER\n"
            + "Example: " + COMMAND_WORD + " deadline";

    public static final String MESSAGE_SUCCESS = "Listed all tasks with order: %1$s";
    
    public static final String MESSAGE_SUCCESS_DEFAULT = "Listed all tasks with order: Default Preset\n"
            + "Tasks are sorted according to these criteria in the order:\n"
            + "Incomplete tasks, Floating tasks, Older tasks,\n"
            + "lastly Name in ascending order.";
    
    public static final String MESSAGE_FAILURE = "Invalid sort parameter given: %1$s\n"
            + "Possible parameters are: default, name/n, starttime/start/s,\n"
            + "endtime/end/e, deadline/dead/d, completed/done/c";

    private final String keyword;
    
    private Boolean invalidKeyword = false;

    /**
     * Parse the keyword given by user based on first character of the input
     * 
     * @param keyword
     *            keyword given by user to sort tasks by
     */
    public SortCommand(String keyword) {
        if (keyword.equals("d") || keyword.equals("deadline") || keyword.equals("dead")) { // deadline
            this.keyword = "Deadline";
        } else if (keyword.equals("s") || keyword.equals("starttime") || keyword.equals("start")) { // start time
            this.keyword = "Start Time";
        } else if (keyword.equals("e") || keyword.equals("endtime") || keyword.equals("end")) { // end time
            this.keyword = "End Time";
        } else if (keyword.equals("c") || keyword.equals("completed") || keyword.equals("done")) { // done status
            this.keyword = "Completed";
        } else if (keyword.equals("n") || keyword.equals("name")) { // name
            this.keyword = "Name";
        } else if (keyword.equals("default") || keyword.equals("")) { // default sorting
            this.keyword = "Default";
        } else {
            this.keyword = keyword;
            invalidKeyword = true;
        }
    }

    /**
     * Executes 'sortFilteredTaskList' and returns success message
     */
    @Override
    public CommandResult execute(boolean isUndo) {
        if (invalidKeyword) {
            return new CommandResult(String.format(MESSAGE_FAILURE, keyword));
        }
        model.sortFilteredTaskList(keyword);
        model.saveCurrentSortPreference(keyword);
        if (keyword.equals("Default")) {
            return new CommandResult(String.format(MESSAGE_SUCCESS_DEFAULT));
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, keyword));
    }

    @Override
    public CommandResult execute(int index) {
        // TODO Auto-generated method stub
        return null;
    }
}
```
###### \java\seedu\task\logic\parser\CommandParser.java
``` java
    /**
     * Used for initial separation of command word and args.
     */

    private static final Pattern BASIC_COMMAND_FORMAT =
            Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern TASK_INDEX_ARGS_FORMAT =
            Pattern.compile("(?<targetIndex>.+)");

    //One or more keywords separated by whitespace
    private static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)");

    private static final Pattern NATURAL_ARGS_FORMAT =
            Pattern.compile("(?<name>[^,#]+)" + "(?<tagArguments>(?: #[^/]+)*)");

    private static final Pattern NATURAL_ARGS_FORMAT_WITH_START_TIME =
            Pattern.compile("(?<name>[^,#]+)" + ", (at|on) (?<startTime>[^@#]+)" + "(?<tagArguments>(?: #[^/]+)*)");

    private static final Pattern NATURAL_ARGS_FORMAT_WITH_DEADLINE =
            Pattern.compile("(?<name>[^,#]+)" + ", by (?<deadline>[^@#]+)" + "(?<tagArguments>(?: #[^/]+)*)");

    private static final Pattern NATURAL_ARGS_FORMAT_WITH_START_AND_END_TIME =
            Pattern.compile("(?<name>[^,#]+)" + ", from (?<startTime>[^@#]+)" + " to (?<endTime>[^@#]+)" + "(?<tagArguments>(?: #[^/]+)*)");

    private static final Pattern NATURAL_ARGS_FORMAT_WITH_START_AND_DEADLINE =
            Pattern.compile("(?<name>[^,#]+)" + ", (at|on) (?<startTime>[^@#]+)" + " (by|to) (?<deadline>[^@#]+)" + "(?<tagArguments>(?: #[^/]+)*)");

    private static final Pattern NATURAL_ARGS_FORMAT_WITH_START_AND_END_TIME_AND_DEADLINE =
            Pattern.compile("(?<name>[^,#]+)" + ", from (?<startTime>[^@#]+)" + "to (?<endTime>[^@#]+)" + "by (?<deadline>[^@#]+)" + "(?<tagArguments>(?: #[^/]+)*)");

    public static final Pattern EDIT_TASK_DATA_ARGS_FORMAT_NATURAL =
            Pattern.compile("(?<targetIndex>[0-9]+)" + " (?<item>[^,]+)" + ", (?<content>.+)");

    public static final Pattern DIRECTORY_ARGS_FORMAT =
            Pattern.compile("(?<directory>[^<>|]+)");
    
    public static final Pattern REPEAT_ARGS_FORMAT =
            Pattern.compile("(?<targetIndex>[0-9]+)" + " (?<interval>[^,]+)");
```
###### \java\seedu\task\logic\parser\CommandParser.java
``` java
    /**
     * Parses arguments in the context of the directory command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDirectory(String args) {
        final Matcher matcher = DIRECTORY_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            String directory = FilePickerUtil.openXMLFile();
            if (directory == "") {
              return new IncorrectCommand("Aborted");
            }
            return new DirectoryCommand(directory);
        }
        return new DirectoryCommand(matcher.group("directory"));
    }

    /**
     * Parses arguments in the context of the backup command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareBackup(String args) {
        final Matcher matcher = DIRECTORY_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            String directory = FilePickerUtil.saveXMLFile();
            if (directory == "") {
              return new IncorrectCommand("Aborted");
            }
            return new BackupCommand(directory);
        }
        return new BackupCommand(matcher.group("directory"));
    }

    /**
     * Parses arguments in the context of the sort tasks command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSort(String args) {
        if (args.equals("")) {
            return new SortCommand("default");
        } else {
            final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SortCommand.MESSAGE_USAGE));
            }
            final String keyword = matcher.group("keywords");
            return new SortCommand(keyword);
        }
    }
    
    /**
     * Parses arguments in the context of the repeat task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareRepeat(String args) {
            final Matcher matcher = REPEAT_ARGS_FORMAT.matcher(args.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RepeatCommand.MESSAGE_USAGE));
            }
            int index = Integer.parseInt(matcher.group("targetIndex"));
            String interval = matcher.group("interval");
            return new RepeatCommand(index, interval);
    }
```
###### \java\seedu\task\model\Model.java
``` java
    /** Updates the sort comparator of the sorted task list to sort by the given comparator*/
    void sortFilteredTaskList(String keyword);
    
    /** Updates sorting method in config based on keyword*/
    void saveCurrentSortPreference(String keyword);
    
    /** Automatically sorts tasks based on current sort preferences in config*/
    public void autoSortBasedOnCurrentSortPreference();
    
    /** asdasd*/
    public void repeatRecurringTask(Task recurringTask);
```
###### \java\seedu\task\model\ModelManager.java
``` java
    @Override
    public void repeatRecurringTask(Task recurringTask) {
        if (!recurringTask.getRecurring().toString().equals("false")) {
            String newStartTime = recurringTask.getStartTime().toString();
            String newEndTime = recurringTask.getEndTime().toString();
            String newDeadline = recurringTask.getDeadline().toString();
            
            if (!newStartTime.equals("")) {
                newStartTime = addPeriodicTimeToTask(recurringTask.getStartTime().toString(), recurringTask.getRecurring().toString());
            }
            if (!newEndTime.equals("")) {
                newEndTime = addPeriodicTimeToTask(recurringTask.getEndTime().toString(), recurringTask.getRecurring().toString());
            }
            if (!newDeadline.equals("")) {
                newDeadline = addPeriodicTimeToTask(recurringTask.getDeadline().toString(), recurringTask.getRecurring().toString());
            }
            
            try {
                Task newTask = new Task(recurringTask.getName(), new StartTime(newStartTime), new EndTime(newEndTime), new Deadline(newDeadline), recurringTask.getTags(), new Status(false, false, recurringTask.getStatus().getFavoriteStatus()), recurringTask.getRecurring());
                taskManager.addTask(newTask);
            } catch (DuplicateTaskException e) {
                e.printStackTrace();
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        }
    }

    private String addPeriodicTimeToTask(String originalTime, String interval) {
        String newTime = "one week after " + originalTime;
        if (interval.equals("daily")) {
            newTime = "one day after " + originalTime;
        } else if (interval.equals("weekly")) {
            newTime = "one week after " + originalTime;
        } else if (interval.equals("fortnightly")) {
            newTime = "two weeks after " + originalTime;
        } else if (interval.equals("monthly")) {
            newTime = "one month after " + originalTime;
        }  else if (interval.equals("yearly")) {
            newTime = "one year after " + originalTime;
        }
        TimeParser parserTime = new TimeParser();
        TimeParserResult time = parserTime.parseTime(newTime);
        StringBuilder newTimeString = new StringBuilder();
        if (time.getRawDateTimeStatus() == DateTimeStatus.START_DATE_START_TIME) {
            newTimeString.append(time.getFirstDate().toString());
            newTimeString.append(" ");
            newTimeString.append(time.getFirstTime().toString().substring(0, 5));
        }
        return newTimeString.toString();
    }
```
###### \java\seedu\task\model\ModelManager.java
``` java
    /**
     * Select sorting method based on keyword
     * 
     * @param keyword keyword to sort tasks by
     */
    public void sortFilteredTaskList(String keyword) {
        if (keyword.equals("Deadline")) {
            taskManager.sortByDeadline();
        } else if (keyword.equals("Start Time")) {
            taskManager.sortByStartTime();
        } else if (keyword.equals("End Time")) {
            taskManager.sortByEndTime();
        } else if (keyword.equals("Completed")) {
            taskManager.sortByDoneStatus();
        } else if (keyword.equals("Name")) {
            taskManager.sortByName();
        } else {
            taskManager.sortByDefaultRules();
        }
        // Save data in that order
        indicateTaskManagerChanged();
    }
    
    /**
     * Updates sorting method in config based on keyword
     * 
     * @param keyword keyword to sort tasks by
     */
    @Override
    public void saveCurrentSortPreference(String keyword) {
        Config config = new Config();
        File configFile = new File("config.json");
        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file " + "config.json" + ": " + e);
            try {
                throw new DataConversionException(e);
            } catch (DataConversionException e1) {
                e1.printStackTrace();
            }
        }
        config.setsortPreference(keyword);
        try {
            ConfigUtil.saveConfig(config, "config.json");
        } catch (IOException e) {
            logger.warning("Error saving to config file : " + e);
            e.printStackTrace();
        }
    }
    
    /**
     * Automatically sorts tasks based on current sort preferences in config
     */
    public void autoSortBasedOnCurrentSortPreference() {
        Config config = new Config();
        File configFile = new File("config.json");
        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file : " + "config.json " + e);
            try {
                throw new DataConversionException(e);
            } catch (DataConversionException e1) {
                e1.printStackTrace();
            }
        }
        String CurrentSortPreference = config.getsortPreference();
        if (!CurrentSortPreference.equals("None")) {
            sortFilteredTaskList(CurrentSortPreference);
        }
    }
```
###### \java\seedu\task\model\task\Deadline.java
``` java
    /**
     * Compares the two Deadlines lexicographically.
     * 
     * @param anotherDeadline
     *            Deadline of another Task to compare to
     */
    public int compareTo(Deadline anotherDeadline) {
        return this.toString().compareTo(anotherDeadline.toString());
    }

    /**
     * Compares the Deadline with Start Time lexicographically.
     * 
     * @param anotherStartTime
     *            Start Time of another Task to compare to
     */
    public int compareTo(StartTime anotherStartTime) {
        return this.toString().compareTo(anotherStartTime.toString());
    }
```
###### \java\seedu\task\model\task\EndTime.java
``` java
    /**
     * Compares the two EndTimes lexicographically.
     * 
     * @param anotherEndTime
     *            EndTime of another Task to compare to
     */
    public int compareTo(EndTime anotherEndTime) {
        return this.toString().compareTo(anotherEndTime.toString());
    }
```
###### \java\seedu\task\model\task\Name.java
``` java
    /**
     * Compares the two Names lexicographically.
     * 
     * @param anotherName
     *            Name of another Task to compare to
     */
    public int compareTo(Name anotherName) {
        return this.toString().compareTo(anotherName.toString());
    }
```
###### \java\seedu\task\model\task\Recurring.java
``` java
public class Recurring {
    
    public static final String MESSAGE_RECURRING_CONSTRAINTS = "Recurring parameter should be daily, weekly, fortnightly monthly, yearly or false";
    public static final String RECURRING_VALIDATION_REGEX = "[\\p{Alnum} ]+";
    
    public String recurringState;

    /**
     * Validates given Recurring parameter.
     *
     * @throws IllegalValueException
     *             if given recurring string is invalid.
     */
    public Recurring(String recurring) throws IllegalValueException {
        assert recurring != null;
        if (!isValidRecurring(recurring)) {
            throw new IllegalValueException(MESSAGE_RECURRING_CONSTRAINTS);
        }
        this.recurringState = recurring;
    }
    
    /**
     * Returns true if a given string is valid as a Recurring parameter.
     */
    public static boolean isValidRecurring(String test) {
        return test.matches(RECURRING_VALIDATION_REGEX);
    }
    
    /**
     * Updates recurringState with input.
     */
    public void setRecurring(String interval) {
        this.recurringState = interval;
    }
    
    @Override
    public String toString() {
        return recurringState;
    }
    

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Recurring // instanceof handles nulls
                && this.recurringState.equals(((Recurring) other).recurringState)); // state check
    }

    @Override
    public int hashCode() {
        return recurringState.hashCode();
    }

}
```
###### \java\seedu\task\model\task\StartTime.java
``` java
    /**
     * Compares the two StartTimes lexicographically.
     * 
     * @param anotherStartTime
     *            StartTime of another Task to compare to
     */
    public int compareTo(StartTime anotherStartTime) {
        return this.toString().compareTo(anotherStartTime.toString());
    }

    /**
     * Compares the Start Time with Deadline lexicographically.
     * 
     * @param anotherStartTime
     *            Start Time of another Task to compare to
     */
    public int compareTo(Deadline anotherDeadline) {
        return this.toString().compareTo(anotherDeadline.toString());
    }
```
###### \java\seedu\task\model\task\Status.java
``` java
    /**
     * Compares the two Statuses based on DoneStatus.
     * 
     * @param anotherStatus
     *            Status of another Task to compare to
     */
    public int compareDoneStatusTo(Status anotherStatus) {
        Boolean isThisDone = new Boolean(this.getDoneStatus());
        Boolean isAnotherDone = new Boolean(anotherStatus.getDoneStatus());
        return isThisDone.compareTo(isAnotherDone);
    }

    /**
     * Compares the two Statuses based on OverdueStatus.
     * 
     * @param anotherStatus
     *            Status of another Task to compare to
     */
    public int compareOverdueStatusTo(Status anotherStatus) {
        Boolean isThisOverdue = new Boolean(this.getOverdueStatus());
        Boolean isAnotherOverdue = new Boolean(anotherStatus.getOverdueStatus());
        return isThisOverdue.compareTo(isAnotherOverdue);
    }
```
###### \java\seedu\task\model\task\Task.java
``` java
    @Override
    public Recurring getRecurring() {
        return recurring;
    }
```
###### \java\seedu\task\model\TaskManager.java
``` java
    //// sort methods

    /**
     * Tasks are sorted according to Deadline in ascending order
     */
    public void sortByDeadline() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task one, Task other) {
                return other.getDeadline().compareTo(one.getDeadline());
            }
        });
    }

    /**
     * Tasks are sorted according to StartTime in ascending order
     */
    public void sortByStartTime() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task one, Task other) {
                return one.getStartTime().compareTo(other.getStartTime());
            }
        });
    }

    /**
     * Tasks are sorted according to EndTime in ascending order
     */
    public void sortByEndTime() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task one, Task other) {
                return one.getEndTime().compareTo(other.getEndTime());
            }
        });
    }

    /**
     * Tasks are sorted according to DoneStatus, starting with completed tasks
     */
    public void sortByDoneStatus() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task one, Task other) {
                return one.getStatus().compareDoneStatusTo(other.getStatus());
            }
        });
    }

    /**
     * Tasks are sorted according to Name in ascending order
     */
    public void sortByName() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task one, Task other) {
                return one.getName().compareTo(other.getName());
            }
        });
    }

    /**
     * Tasks are sorted according to these criteria in the order: Incomplete
     * tasks, Floating tasks, Older tasks, lastly Name in ascending order.
     */
    public void sortByDefaultRules() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task one, Task other) {
                // Incomplete tasks first
                int statusResult = one.getStatus().compareDoneStatusTo(other.getStatus());
                // Older tasks first
                int deadlineResult = one.getDeadline().compareTo(other.getDeadline());
                int startTimeResult = one.getStartTime().compareTo(other.getStartTime());
                int timeResult;
                if (deadlineResult == 0 && startTimeResult == 0) {
                    timeResult = 0;
                } else if (!one.getDeadline().toString().equals("") && !other.getStartTime().toString().equals("")) {
                    timeResult = one.getDeadline().compareTo(other.getStartTime());
                } else if (!one.getStartTime().toString().equals("") && !other.getDeadline().toString().equals("")) {
                    timeResult = one.getStartTime().compareTo(other.getDeadline());
                } else if (!(deadlineResult == 0)) {
                    timeResult = deadlineResult;
                } else {
                    timeResult = startTimeResult;
                }
                // Name in ascending order
                int nameResult = one.getName().compareTo(other.getName());

                if (statusResult == 0) {
                    if (timeResult == 0) {
                        return nameResult;
                    } else {
                        return timeResult;
                    }
                } else {
                    return statusResult;
                }
            }
        });
    }
```
