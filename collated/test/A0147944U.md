# A0147944U
###### \java\guitests\BackupCommandTest.java
``` java
package guitests;

import org.apache.commons.io.FileUtils;
import org.junit.Test;

import seedu.task.commons.core.LogsCenter;
import seedu.task.commons.util.ConfigUtil;
import seedu.task.logic.commands.BackupCommand;
import seedu.task.testutil.TestUtil;
import seedu.task.testutil.TypicalTestTasks;

import static org.junit.Assert.assertTrue;

import java.io.File;
import java.util.logging.Logger;

public class BackupCommandTest extends TaskManagerGuiTest {

    private static final Logger logger = LogsCenter.getLogger(ConfigUtil.class);

    public static final String filepath_A = TestUtil.getFilePathInSandboxFolder("backup_not_pre_existing");
    public static final String filepath_B = TestUtil.getFilePathInSandboxFolder("backup_pre_existing");
    public static final String filepath_C = "c:/inaccessible";
    public static final String filepath_D = "invalid:/drive";
    public static final String filepath_E = "c:/invalid>character";
    public static final String filepath_F = TestUtil.getFilePathInSandboxFolder("protected");

    @Test
    public void backup() {
        // Remove backup_not_pre_existing.xml if it exists
        File notSupposedToBeHere = new File(filepath_A+ ".xml");
        if (notSupposedToBeHere.exists()) {
            logger.info("'backup_not_pre_existing' exists");
            if(FileUtils.deleteQuietly(notSupposedToBeHere)) {
                logger.info("Not anymore");
            } else {
                logger.warning("Unable to delete backup_not_pre_existing");
            }
        } else {
            logger.info("'backup_not_pre_existing' does not exist ");
        }
        
        //verify an empty TaskManager can be backed up in a valid directory
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage("Task manager has been cleared!");
        commandBox.runCommand("backup " + filepath_A);
        assertResultMessage(String.format(BackupCommand.MESSAGE_BACKUP_SUCCESS, filepath_A + ".xml", "created"));
        
        //verify a non-empty TaskManager can be backed up in a valid directory
        commandBox.runCommand("add Help Jim with his task, at 2016-10-25 9am");
        assertTrue(taskListPanel.isListMatching(TypicalTestTasks.taskH));
        commandBox.runCommand("backup " + filepath_B);
        assertResultMessage(String.format(BackupCommand.MESSAGE_BACKUP_SUCCESS, filepath_B + ".xml", "overwritten"));
        
        //verify TaskManager can be backed up in a valid directory onto an existing backup
        commandBox.runCommand("backup " + filepath_A);
        assertResultMessage(String.format(BackupCommand.MESSAGE_BACKUP_SUCCESS, filepath_A + ".xml", "overwritten"));

        /* Disabled as Travis is does not have an inaccessible directory, works locally on windows
        //verify a TaskManager can't be backed up in an inaccessible directory
        commandBox.runCommand("backup " + filepath_C);
        assertResultMessage(String.format(BackupCommand.MESSAGE_BACKUP_FAILURE, filepath_C + ".xml"));
        */
        
        /* Disabled as unable to test with FilePicker
        //verify if invalid directory given, FilePicker will be presented
        commandBox.runCommand("backup " + filepath_D);
        assertResultMessage(String.format(BackupCommand.MESSAGE_BACKUP_FAILURE, filepath_D + ".xml"));
        commandBox.runCommand("backup " + filepath_E);
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, BackupCommand.MESSAGE_USAGE));
        */
        
        /* Disabled as Travis does not respect read-only protection
        //verify a TaskManager will detect if a file is protected
        commandBox.runCommand("backup " + filepath_F);
        assertResultMessage(String.format(BackupCommand.MESSAGE_BACKUP_ERROR, filepath_F + ".xml"));
        */
    }
}
```
###### \java\guitests\RepeatCommandTest.java
``` java
public class RepeatCommandTest extends TaskManagerGuiTest {

    @Test
    public void repeat() {

        // repeat a random task in the list daily
        TestTask[] currentList = td.getTypicalTasks();
        int targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "daily");

        // repeat a random task in the list weekly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "weekly");

        // repeat a random task in the list fortnightly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "fortnightly");

        // repeat a random task in the list monthly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "monthly");

        // repeat a random task in the list yearly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "yearly");

        // stop repeating the task that was just repeated
        assertRepeatSuccess(targetIndex, currentList, "stop");

        // repeat a random task in the list daily
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "d");

        // repeat a random task in the list weekly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "w");

        // repeat a random task in the list fortnightly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "f");

        // repeat a random task in the list monthly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "m");

        // repeat a random task in the list yearly
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatSuccess(targetIndex, currentList, "y");

        // stop repeating the task that was just repeated
        assertRepeatSuccess(targetIndex, currentList, "end");

        // incorrect index
        assertRepeatWrongIndexFailure(50, currentList, "daily");

        // incorrect interval
        targetIndex = ThreadLocalRandom.current().nextInt(1, (currentList.length + 1));
        assertRepeatWrongIntervalFailure(targetIndex, currentList, "incorrect interval");
    }

    /**
     * Runs the repeat command to delete the task at specified index and
     * confirms the result is correct.
     * 
     * @param targetIndexOneIndexed
     *            e.g. to repeat the first task in the list, 1 should be given
     *            as the target index.
     * @param currentList
     *            A copy of the current list of tasks (before repeat command).
     */
    private void assertRepeatSuccess(int targetIndexOneIndexed, final TestTask[] currentList, String input) {
        TestTask taskToRepeat = currentList[targetIndexOneIndexed - 1]; // -1 because array uses zero indexing

        // confirm initial recurring parameter for task is different
        if (input.equals("stop") || input.equals("end")) {
            assertFalse(taskListPanel.getTask(targetIndexOneIndexed - 1).getRecurring().toString().equals("false"));
        } else {
            assertFalse(taskListPanel.getTask(targetIndexOneIndexed - 1).getRecurring().toString().equals(input));
        }

        commandBox.runCommand("repeat " + targetIndexOneIndexed + " " + input);

        // change value of input as command may store data as different value
        // for "stop" input
        if (input.equals("stop") || input.equals("end")) {
            input = "false";
        } else if (input.equals("d")) {
            input = "daily";
        } else if (input.equals("w")) {
            input = "weekly";
        } else if (input.equals("f")) {
            input = "fortnightly";
        } else if (input.equals("m")) {
            input = "monthly";
        } else if (input.equals("y")) {
            input = "yearly";
        }

        // task
        assertTrue(taskListPanel.getTask(targetIndexOneIndexed - 1).getRecurring().toString().equals(input));

        // confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_REPEAT_TASK_SUCCESS, taskToRepeat.getName().toString(), input));
    }

    private void assertRepeatWrongIndexFailure(int targetIndexOneIndexed, final TestTask[] currentList, String input) {

        commandBox.runCommand("repeat " + targetIndexOneIndexed + " " + input);

        // confirm the result message is correct
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    private void assertRepeatWrongIntervalFailure(int targetIndexOneIndexed, final TestTask[] currentList,
            String input) {

        commandBox.runCommand("repeat " + targetIndexOneIndexed + " " + input);

        // confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_INVALID_INTERVAL, input));
    }

}
```
###### \java\guitests\SortCommandTest.java
``` java
public class SortCommandTest extends TaskManagerGuiTest {
    
    @Test
    public void sort() {
        
    
        //verify if tasks are sorted correctly
        
        
        assertSortOrderCorrect("deadline");
        assertSortOrderCorrect("d");
    }
    
    private void assertSortOrderCorrect(String parameter) {
        int size = td.getTypicalTasks().length;
        if (ThreadLocalRandom.current().nextBoolean()) {
            commandBox.runCommand("sort " + parameter);
        } else {
            commandBox.runCommand("s " + parameter);
        }
        if (parameter.equals("d") || parameter.equals("deadline") || parameter.equals("dead")) {
            assertResultMessage(String.format(SortCommand.MESSAGE_SUCCESS, "Deadline"));
        } else if (parameter.equals("s") || parameter.equals("starttime") || parameter.equals("start")) { // start time
            assertResultMessage(String.format(SortCommand.MESSAGE_SUCCESS, "Start Time"));
        } else if (parameter.equals("e") || parameter.equals("endtime") || parameter.equals("end")) { // end time
            assertResultMessage(String.format(SortCommand.MESSAGE_SUCCESS, "End Time"));
        } else if (parameter.equals("c") || parameter.equals("completed") || parameter.equals("done")) { // done status
            assertResultMessage(String.format(SortCommand.MESSAGE_SUCCESS, "Completed"));
        } else if (parameter.equals("n") || parameter.equals("name")) { // name
            assertResultMessage(String.format(SortCommand.MESSAGE_SUCCESS, "Name"));
        } else if (parameter.equals("default") || parameter.equals("")) { // default sorting
            assertResultMessage(String.format(SortCommand.MESSAGE_SUCCESS, "Default"));
            return;
        }
        int targetIndexOneIndexed = 0;
        taskListPanel.getTask(targetIndexOneIndexed  - 1);
    }
    
}
```
###### \java\seedu\task\commons\core\ConfigTest.java
``` java
public class ConfigTest {
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void toString_defaultObject_stringReturned() {
        String defaultConfigAsString = "App title : Task App\n" +
                                       "Current log level : INFO\n" +
                                       "Preference file Location : preferences.json\n" +
                                       "Local data file location : data/taskmanager.xml\n" +
                                       "TaskManager name : MyTaskManager\n" +
                                       "Current Sorting Preference : Default";

        assertEquals(defaultConfigAsString, new Config().toString());
    }

    @Test
    public void equalsMethod() {
        Config defaultConfig = new Config();
        assertFalse(defaultConfig.equals(null));
        assertTrue(defaultConfig.equals(defaultConfig));
    }

}
```
###### \java\seedu\task\TestApp.java
``` java
    @Override
    protected Config initConfig(String configFilePath) {
        Config config = super.initConfig(configFilePath);
        config.setAppTitle(APP_TITLE);
        config.setTaskManagerFilePath(saveFileLocation);
        config.setUserPrefsFilePath(DEFAULT_PREF_FILE_LOCATION_FOR_TESTING);
        config.setTaskManagerName(TASK_MANAGER_NAME);
        config.setsortPreference("None");
        try {
            ConfigUtil.saveConfig(config, "config.json");
        } catch (IOException e) {
            e.printStackTrace();
        }
        return config;
    }
```
